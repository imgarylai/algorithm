# 66. Plus One

[66. Plus One](https://leetcode.com/problems/plus-one/)

將題目給的陣列反過來做，一個一個去判斷是不是有進位，需不需要加一。

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        m = len(digits)
        res = []
        carry = False
        for i in reversed(range(m)):
            if carry or i == m - 1:
                digit = digits[i] + 1
                res.append(digit % 10)    
                carry = digit > 9
            else:
                res.append(digits[i])
        if carry:
            res = res + [1]
        return reversed(res)
```

這個方法可以，不過有一個更有效的方法可以處理後面的題目。

我們其實最需要擔心的，就是最右邊的數字是不是九，如果不是九的話，其實加一後就沒有事情了，但如果是九，加一後就要進位，繼續看看「左邊」一個數字是不是九。例如：`[9,9,9]` 這樣的情況。

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:

        for i in reversed(range(len(digits))):
            if digits[i] == 9:
                ## 連續遇到 9 就是一直加
                digits[i] = 0
            else:
                # 因為是反著遍歷，所以說很有可能一開始就直接加一就返回
                # 如果或是上一次是 9 這次不是 9 ，所以直接加一
                digits[i] += 1
                return digits
        # 遇到全部都是 9 的情況，只好再加一
        return [1] + digits
```

